<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-11-01 Fri 11:44 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>zero-knowledge proofs</title>
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">zero-knowledge proofs</h1>
<div id="outline-container-orgf087b90" class="outline-2">
<h2 id="orgf087b90"><span class="section-number-2">1.</span> Zero-knowledge proofs</h2>
<div class="outline-text-2" id="text-1">
<p>
Zero-knowledge proofs are protocoles that allow someone to prove to someone else that he knows a specific piece of information without having to reveal the information itself.
</p>

<p>
They are used to prove knowledge of simple mathematicals statements such as:
</p>
<ul class="org-ul">
<li>knowledge of a discrete logarithm (w.r.t. a generator g).</li>
<li>knowledge of a quadratic residue.</li>
<li>knowledge of Hamiltonian Cycle for a large graph</li>
<li>&#x2026;</li>
</ul>
<p>
Recently, general-purpose zero-knowledge proofs allows proving knowledge of any logicial statements, even complex ones. This is done by constructing Arithmetic Circuits of statements and prove satisfability.
</p>

<p>
They are called "zero-knowledge" because we want to reveal absolutely <b>nothing</b> about the secret information.
(* In some cases we only want to prove the existance of a solution, not the knowledge of a solution. In this case they are called Zero-Knowledge Arguments.)
</p>

<p>
Because they are proof systems, they also need two have importantes properties:
</p>
<ul class="org-ul">
<li>soundness: it should not be possible to generate proofs of false statements</li>
</ul>
<p>
(* Proof vs Argument: We say ZK <b><b>Proof</b></b> for perfect soundness, and ZK <b><b>Argument</b></b> for computational soundness, which is the case with pairing-based cryptography *)
</p>
<ul class="org-ul">
<li>completeness: it should always be possible to prove statements when we know the secret.</li>
</ul>

<p>
Unlike other proof systems they rely on assumptions on cryptographic primitives. As such, they are probabilistic proofs, and while soundness can theoritically be compremize, it is undoable in practice as it can only happen with very low probability.
</p>

<p>
These properties can often be proved as followed:
</p>
<ul class="org-ul">
<li>Completness: By the mathematical construction of the protocol. There is often a simple algorithm that produces outputs for every input.</li>
<li>Soundness: By relying on the cryptographic assumptions, we can prove that finding a solution (generating an accepted response) without knowing the secret would require(be transposed/be reduced to) solving a hard problem/assumption, such as the DDH (Decisional Diffie Hellman Hypothesis), &#x2026;</li>
<li>Zero-Knowledge: Anyone can generate transcript indistinguishable from real (valid) ones.</li>
</ul>
<p>
(* This is because it is often possible to generate transcript a-posteriori, saying that (for exemple in the case of sigma protocols) given a challenge, one can find a value for a commitment that works. The hardness reside in generating a response <b>given an a-priori commitment</b> and a random challenge. <b>)
(</b> In general, we only know how to prove the Honest-Verifier-Zero-Knowledge (HVZK), which required the verifier follow that protocol, that is the case of sigma ptocols not trying to crafting malicious challenge. In NIZKP, Full Zero-Knowledge and HVZK are the same. *)
</p>
</div>
</div>
<div id="outline-container-org7b5ec01" class="outline-2">
<h2 id="org7b5ec01"><span class="section-number-2">2.</span> Sigma protocoles</h2>
<div class="outline-text-2" id="text-2">
<p>
In Sigma protocoles, the prover P want to prove he knows some secret to a verifier V.
</p>

<p>
This can be done in 3 steps:
P -&gt; V (commitment)
V -&gt; P (challenge)
P -&gt; V (response)
</p>

<p>
The commitment step often allows the prover not to leak informations when generating the response. It can be for exemple a value from which he knows a discrete logarithm. It also binds the prover to a specific value that he would have to compute the response from.
The challenge should be chosen at random by the verifier, independently of the commitment.
The response should be a value that could only be generated if P knows the secret.
</p>
</div>
</div>
<div id="outline-container-org5b9da80" class="outline-2">
<h2 id="org5b9da80"><span class="section-number-2">3.</span> Non Interactive Zero-Knowledge Proofs: The Fiat Shamir Transform</h2>
<div class="outline-text-2" id="text-3">
<p>
(* Maybe rename Non Interactive Sigma Protocols Since Groth-Sahai ?)
</p>

<p>
\(challenge = Hahs(context + commitment)\)
</p>

<p>
Zero-knowdge proof are born as interactive protocols with two parties, since they require the prover to respond to a random challenge from the verifier.
However, we found that we can always use random oracles such as hash function to generate the challenge.
This is called the Fiat-Shamir Heuristic (or Fiat-Shamir Technique, or Fiat-Shamir Transformation).
We hash the context (including commitments). This gives us an uniform random value in the random oracle model (where hash function are supposed perfect random oracles). We use that instead of the prover's challenge. By doing so, the Zero-Knowledge Proof can be made a Non-Interactive Zero-Knowledge Proof (NIZKP), and it can be done by the prover alone.
</p>

<p>
@inproceedings{fiat1986prove,
  title={How to prove yourself: Practical solutions to identification and signature problems},
  author={Fiat, Amos and Shamir, Adi},
  booktitle={Conference on the theory and application of cryptographic techniques},
  pages={186&#x2013;194},
  year={1986},
  organization={Springer}
}
</p>

<p>
NOTE
Pairing based cryptography such as the BLS signature scheme and Groth-Sahai
proofs are Non-Interactive without needing the Fiat-Shamir Transform.
This is due only to the algebraic structure provided by bilinear pairing.
</p>
</div>
</div>
<div id="outline-container-orgcc9ed23" class="outline-2">
<h2 id="orgcc9ed23"><span class="section-number-2">4.</span> Annexe: Interactive vs Non-Interactive: The case of repudiation</h2>
<div class="outline-text-2" id="text-4">
<p>
While Non Interactive ZKP are much more practial because we don't need another party,
there is some cases where we want repudiability, and that can only be achieved with interactive ZKP.
</p>

<p>
We've seen that it is often possible to generate transcript for false statements when done out-of-order (for exemple by generate a commitment given the challenge). Hence, interactive zkp have <b><b>plausible deniability</b></b> by nature (they are repudiable). By the transcript alone we cannot be convinced that the prover knows the secret. This is because the prover and the verifier could have collude.
</p>

<p>
By using the Fiat-Shamir transformation, colluding becomes impossible, (since it is not possible (in practice) to find a pre-image of a secure cryptographic hash function). That makes NIZKP non-repudiable, and this is by purpose, since we want exactly that: Being certain that the prover knows the secret.
</p>

<p>
A good exemple of non-repudiable ZKP are digital signature like Schnorr Signatures (used in EdDSA).
</p>

<p>
However in some contexts, such as some e-voting protocols that allows us to verify our vote using a second device, we want it to be repudiable using Interactive ZKP, so that we would have plausible deniability when showing the transcript to a coercer.
</p>
</div>
</div>
<div id="outline-container-org7e58fd9" class="outline-2">
<h2 id="org7e58fd9"><span class="section-number-2">5.</span> Annexe: Designated-Verifier Non-Interactive Zero-Knowledge Proofs (DVNIZKP) (TODO)</h2>
<div class="outline-text-2" id="text-5">
<p>
Also provide "plausible deniability".
</p>

<p>
I don't understand from a paper I read that the proof can only be checked by a designated-verifier (a possessor of a private key).
I want thinking that the proof can be fooled if possessing the private key. Hence only the only possessor of the private key, by knowing he never shared it, can trust the proof.
</p>
</div>
</div>
<div id="outline-container-orgfcf1508" class="outline-2">
<h2 id="orgfcf1508"><span class="section-number-2">6.</span> Annexe: Signature-of-Knowledge</h2>
<div class="outline-text-2" id="text-6">
<p>
A NIZKP can always be transformed to a signature scheme by adding the data to be signed to the context of the hashed string used by the Fiat-Shamir transform.
</p>
</div>
</div>
<div id="outline-container-org854579a" class="outline-2">
<h2 id="org854579a"><span class="section-number-2">7.</span> Annexe: Commitments Schemes</h2>
<div class="outline-text-2" id="text-7">
<p>
Commitments schemes is a concept intricated with ZKP.
They constitute the first part of Sigma protocols.
</p>

<p>
One can <b><b>commit</b></b> to a specific value while keeping it hidden using a <b><b>commitment scheme</b></b>.
Later, the committed value can be revealed (we say that one <b><b>open</b></b> the commitment).
It can be done (in simple schemes) by revealing the committed value itself, or by revealing some secrets (in more complex scheme, and especially in the case of partial reveal).
</p>

<p>
<b>Definition:</b> It can be modelled with 3 algorithm: <b><b>c = commit(x,&#x2026;)</b></b>, <b><b>reveal(c,&#x2026;)</b></b> and <b><b>verify(c,x,&#x2026;)</b></b>.
<b>Properties:</b> A commitment scheme is either perfectly or computationaly <b><b>hiding</b></b> (the chosen value) value and either perfectly or computationaly <b><b>binding</b></b> (to the chosen value).
</p>

<p>
It is useful in the first phase of a Sigma protocol, as intuitivly adding some random but fixed from the start noise to a specific statement can help hiding our secret while proving his knowledge.
</p>
</div>
<div id="outline-container-org534c292" class="outline-3">
<h3 id="org534c292"><span class="section-number-3">7.1.</span> Exemple: One Way Functions</h3>
<div class="outline-text-3" id="text-7-1">
<p>
We suppose a one-way function `f`.
</p>

<p>
[c = f(x)] (committed value: x)
</p>

<p>
c = commit(x) : f(x)
    reveal(c) : x (trivial)
    verify(c, x): c == f(x) (trivial)
</p>

<p>
Exemple:
</p>
<ul class="org-ul">
<li>cryptographic hash functions</li>
</ul>
<p>
[c = hash(x)]
</p>
<ul class="org-ul">
<li>g<sup>x</sup> in finite prime-order groups (where the DDH hold).</li>
</ul>
<p>
[c = g<sup>x</sup>]
</p>
<ul class="org-ul">
<li>&#x2026;</li>
</ul>
</div>
</div>
<div id="outline-container-orgb1f1c36" class="outline-3">
<h3 id="orgb1f1c36"><span class="section-number-3">7.2.</span> Exemple: Pedersen Commitment</h3>
<div class="outline-text-3" id="text-7-2">
<p>
We suppose a (prime-order) finite group with two generators `g` and `h`.
</p>

<p>
[c = g<sup>x</sup> * h<sup>y</sup>] (committed values: x et y)
</p>

<p>
c = commit(x,y) : g<sup>x</sup> * h<sup>y</sup>
    reveal(c)   : (x,y) (trivial)
    verify(c,x,y): c == commit(x,y) (trivial)
</p>

<p>
NOTE: Interestingly, they have homomorphic properties.
</p>
</div>
</div>
<div id="outline-container-orgf614038" class="outline-3">
<h3 id="orgf614038"><span class="section-number-3">7.3.</span> Exemple: Merkle tree</h3>
<div class="outline-text-3" id="text-7-3">
<p>
We suppose a cryptographic hash function `H`.
</p>

<p>
[c = H(H(x0,x1),H(x2,x2))] (committed values: x0,&#x2026;,xn)
</p>

<p>
c = commit(x0,x1,x2,x3,&#x2026;,x<sub>n</sub>) : hash<sub>root</sub>
    reveal(x<sub>i</sub>): x<sub>i</sub> + all intermediary hashes
    verify: H(I0,H(I1,H(I2,&#x2026;x<sub>i</sub>))) == c
</p>
</div>
</div>
<div id="outline-container-org352492e" class="outline-3">
<h3 id="org352492e"><span class="section-number-3">7.4.</span> <span class="todo TODO">TODO</span> Exemple: KZG commitment</h3>
</div>
</div>
<div id="outline-container-orga7090ef" class="outline-2">
<h2 id="orga7090ef"><span class="section-number-2">8.</span> Real-world Zero-Knowledge Proofs</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org17bc5c7" class="outline-3">
<h3 id="org17bc5c7"><span class="section-number-3">8.1.</span> Knowledge of a discrete logarithm (= Belenios pok)</h3>
</div>

<div id="outline-container-org0acb6a9" class="outline-3">
<h3 id="org0acb6a9"><span class="section-number-3">8.2.</span> Schnorr Signatures (=~ Belenios pok)</h3>
</div>

<div id="outline-container-org9e706cd" class="outline-3">
<h3 id="org9e706cd"><span class="section-number-3">8.3.</span> (Belenios interval proof)</h3>
</div>

<div id="outline-container-org6b99f7b" class="outline-3">
<h3 id="org6b99f7b"><span class="section-number-3">8.4.</span> (Belenios nonzero ?)</h3>
</div>

<div id="outline-container-orga6d2f22" class="outline-3">
<h3 id="orga6d2f22"><span class="section-number-3">8.5.</span> (Belenios shuffle proof ?)</h3>
</div>

<div id="outline-container-org8b68805" class="outline-3">
<h3 id="org8b68805"><span class="section-number-3">8.6.</span> Borromean Ring Signatures</h3>
</div>

<div id="outline-container-org626e4a7" class="outline-3">
<h3 id="org626e4a7"><span class="section-number-3">8.7.</span> (Zerocoin Signatures)</h3>
</div>

<div id="outline-container-orgdcc86e3" class="outline-3">
<h3 id="orgdcc86e3"><span class="section-number-3">8.8.</span> (Quadratic residue (QR))</h3>
</div>

<div id="outline-container-orgc6e20c7" class="outline-3">
<h3 id="orgc6e20c7"><span class="section-number-3">8.9.</span> Bulletproofs</h3>
</div>

<div id="outline-container-org35e2545" class="outline-3">
<h3 id="org35e2545"><span class="section-number-3">8.10.</span> (Groth-Sahai Proofs)</h3>
</div>

<div id="outline-container-org01d6b42" class="outline-3">
<h3 id="org01d6b42"><span class="section-number-3">8.11.</span> ZK-SNARKs (=? Groth16)</h3>
</div>

<div id="outline-container-org5fb1539" class="outline-3">
<h3 id="org5fb1539"><span class="section-number-3">8.12.</span> ZK-STARKs (=? Groth16)</h3>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2024-11-01 Fri 11:44</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
